---
title: "LFQ comparison"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plyr)
library(dplyr)
library(stringr)
library(limma)
library(PECA)
library(vsn)
library(pROC)
library(kableExtra)
library(ggplot2)
```

## True Ratios

The 48 UPS proteins (Sigma Aldrich) were spiked into an *E. coli* background. UPS1 has all 48 UPS proteins at the same concentration, while UPS2 has varying concentrations. We define the ratio as UPS2 / UPS1, so the true ratios run from 10 to $10^{-4}$ -- in addition, 8 proteins have the same concentration in UPS2 and UPS1. The proteins and their associated UPS2/UPS1 ratios are defined below:

```{r}
ups_protein_ids <- c(
    #ratio of 10
    "P00915",
    "P00918",
    "P01031",
    "P69905",
    "P68871",
    "P41159",
    "P02768",
    "P62988",
    # ratio of 1
    "P04040",
    "P00167",
    "P01133",
    "P02144",
    "P15559",
    "P62937",
    "Q06830",
    "P63165",
    # ratio of 0.1
    "P00709",
    "P06732",
    "P12081",
    "P61626",
    "Q15843",
    "P02753",
    "P16083",
    "P63279",
    # ratio of 0.01
    "P01008",
    "P61769",
    "P55957",
    "O76070",
    "P08263",
    "P01344",
    "P01127",
    "P10599",
    # ratio of 0.001
    "P99999",
    "P06396",
    "P09211",
    "P01112",
    "P01579",
    "P02787",
    "O00762",
    "P51965",
    # ratio of 0.0001
    "P08758",
    "P02741",
    "P05413",
    "P10145",
    "P02788",
    "P10636",
    "P00441",
    "P01375"
)

ups_true_df <- data.frame(protid = ups_protein_ids,
                          ratios = c(rep(10, 8),
                                     rep(1, 8),
                                     rep(0.1, 8),
                                     rep(1e-2, 8),
                                     rep(1e-3, 8),
                                     rep(1e-4, 8)),
                          stringsAsFactors = FALSE)

# find the protein ids for proteins that are constant
ups_non_de <- filter(ups_true_df, ratios == 1)$protid
```


## Quantification Results

We analyze 6 different result files on the peptide level, and 2 different result files on the protein level. The peptide files are as follows:

* moFF's peptide summary, produced from MaxQuant's `msms.txt` - run with/without MBR (2 files)
* FlashLFQ's peptide file: `msms_FlashLFQ_QuantifiedBaseSequences.tsv` - produced from MaxQuant's `msms.txt` and run with/without MBR (2 files)
* MaxQuant's peptide file: `peptides.txt`, from MaxQuant, with/without MBR (2 files)

The 2 protein files are MaxQuant's protein report (`proteinGroups.txt`), from MaxQuant run with/without MBR. 

In the following, we read in all of the results files. In most cases, the protein IDs are in a list, separated by ";", so we use the function `take_first_protein()` to get the first protein in the list. 
```{r}
take_first_protein <- function(prot_vec){
    str_split(prot_vec, ";", simplify = TRUE)[, 1]
}
```

We don't want any character columns to be read as factors:
```{r}
options(stringsAsFactors = FALSE)
```

### FlashLFQ

```{r flash}
flash <- read.delim("2019_datasets/UPS/FlashLFQ_UPS/Galaxy104-[FlashLFQ_on_data_39,_data_38,_and_others__QuantifiedPeptides.tsv].tabular",
                    stringsAsFactors = FALSE) %>%
    rename(peptide = Sequence, prot = Protein.Groups) %>%
    select(peptide, prot, starts_with("Intensity"))
flash$prot <- take_first_protein(flash$prot)
flash_names <- names(flash)
flash$peptide <- gsub("NH2-","", gsub("-COOH","", flash$peptide))

# flash no mbr
flash_no_mbr <- read.delim("2019_datasets/UPS/flash_noMbr/Galaxy100-[FlashLFQ_on_data_39,_data_38,_and_others__QuantifiedPeptides.tsv].tabular",
                           stringsAsFactors = FALSE) %>%
    rename(peptide = Sequence, prot = Protein.Groups) %>%
    select(peptide, prot, starts_with("Intensity"))
flash_no_mbr$prot <- take_first_protein(flash_no_mbr$prot)
flash_no_mbr$peptide <- gsub("NH2-","", gsub("-COOH","", flash_no_mbr$peptide))
```

### moFF
```{r moff}
moff <- read.delim("2019_datasets/UPS/moff/Galaxy13-[moFF_on_data_1,_data_2,_and_others__peptide_summary].tabular",
                   stringsAsFactors = FALSE)
# replace protein list with first protein
moff$prot <- take_first_protein(moff$prot)
moff_names <- names(moff)
moff <- moff[,c(1,2,9,7,8,4,3,5,10,6)]
```

When moFF is run without MBR, we need to combine all of the individual peptide summaries, which we do with `join_all` from `plyr`. 

```{r moff_no_mbr}
# moff, no mbr
moff_files <- list.files('2019_datasets/UPS/moff_noMbr/peptide\ summary/',
                    full.names = TRUE)
#tail(unlist(str_split(moff_files[1], "/")), n=1)

moff_no_mbr <- lapply(moff_files, function(i) df = read.delim(i, as.is = TRUE) %>% 
  rename(!!paste("sumIntensity_20130510_EXQ1_IgPa_QC_",
                 str_extract(i, "UPS[0-9_]+"), sep="") := sumIntensity_UPS_PSM)) %>%
                        join_all(by=c("peptide", "prot"), type = "full")
moff_no_mbr$prot <- take_first_protein(moff_no_mbr$prot)
```

### MaxQuant

#### Peptides
```{r mqpep}
mq <- read.delim("2019_datasets/UPS/MQ_1pep/peptides.txt",
                 stringsAsFactors = FALSE) %>%
    rename(peptide = Sequence, prot = Proteins) %>%
    select(peptide, prot, starts_with("Intensity."))
mq$prot <- take_first_protein(mq$prot)
mq_names <- names(mq)

# mq no mbr
mq_no_mbr <- read.delim("2019_datasets/UPS/MQ_1pep_noMBR/peptides.txt",
                        stringsAsFactors = FALSE) %>%
    rename(peptide = Sequence, prot = Proteins) %>%
    select(peptide, prot, starts_with("Intensity."))
mq_no_mbr$prot <- take_first_protein(mq_no_mbr$prot)
```

#### Proteins

With the MaxQuant protein reports, we are going to do a t-test on each row of the data matrix, rather than using `PECA` as for the peptide-level analysis. Therefore, we filter the results to keep only the proteins that had values in 3 out of 4 replicates for both groups, which is the minimum necessary for a robust T-test. 

```{r mqprot}
mq_prot_analysis <- function(proteinGroups, name){
    #don't remove contaminants, because some UPS proteins are potential contam
    mq_prot <- read.delim(proteinGroups,
                      na.strings = c("0", "", "NA"),
                      stringsAsFactors = FALSE) %>%
        filter(is.na(Reverse)) %>% # if not decoy, is na
        mutate(prot = take_first_protein(Protein.IDs),
               ups_prot_id = str_split(prot, "ups\\|", simplify = TRUE)[, 1]) %>%
        mutate(ups = str_detect(prot, "ups"), de = ups & !(ups_prot_id %in% ups_non_de)) %>%
        select(prot, ups, de, starts_with("LFQ"), ups_prot_id)
    
    # filter to 3 or more observations
    mq_prot$enough_obs <- rowSums(is.na(mq_prot[4:7])) <= 1 &
        rowSums(is.na(mq_prot[8:11])) <= 1
    mq_prot_filt <- filter(mq_prot, enough_obs) %>% select(-enough_obs)
    
    # t testing
    mq_ts <- rep(0, nrow(mq_prot_filt))
    for (i in 1:nrow(mq_prot_filt)){
        mq_ts[i] <- t.test(x = mq_prot_filt[i, 4:7], y = mq_prot_filt[i, 8:11])$p.value
    }
    mq_prot_filt$p.fdr <- p.adjust(mq_ts, method = "fdr")
    mq_prot_filt$sr <- rowMeans(mq_prot_filt[, 8:11], na.rm = TRUE)/
        rowMeans(mq_prot_filt[, 4:7], na.rm = TRUE)
    # mq_roc <- roc(mq_prot_filt$de, mq_prot_filt$p.fdr)
    joined_mq <- filter(mq_prot_filt, ups) %>%
        left_join(ups_true_df, by = c("ups_prot_id" = "protid")) 
    rmsle <- sqrt(mean((log10(joined_mq$sr) - log10(joined_mq$ratios))^2, na.rm = TRUE))
    mq_data <- data.frame("Var1" = "MaxLFQ", "Var2" = name, rmsle = rmsle)
    list("full_df" = mq_prot_filt, "rmlse" = mq_data, "joined_mq" = joined_mq)
}

# mq prot
mq_data <- mq_prot_analysis("2019_datasets/UPS/MQ_1pep/proteinGroups.txt", "MaxQuant")

# mq prot, no mbr
mq_no_mbr_data <- mq_prot_analysis("2019_datasets/UPS/MQ_1pep_noMBR/proteinGroups.txt", "MaxQuant_no_MBR")
```

## Differential expression analysis and ratio estimation

Below is the function that is used on all of the peptide reports to normalize and then test for differential expression. The R/Bioconductor package `limma` is used for normalization, and the package `PECA` is used to "roll-up" from peptides to proteins and to test for differential expression (using a modified t-test). Then, `roc` from the `pROC` package is used to create a ROC curve, from which the AUC is estimated. 

```{r testfun}
peptides_normalize_and_test_de <- function(df,
                              int_col_vec,
                              id_col_name,
                              norm_method,
                              grp1_col_name,
                              grp2_col_name){
    if (norm_method == "vsn"){
        intensities <- 2^limma::normalizeVSN(as.matrix(df[, int_col_vec]))
    } else {
        intensities <- 2^(limma::normalizeBetweenArrays(log2(as.matrix(df[, int_col_vec])),
                                                        method = norm_method))
    }
    df_norm <- data.frame(peptide = df$peptide,
                          prot = df$prot,
                          intensities,
                          stringsAsFactors = FALSE)
    df_peca <- PECA::PECA_df(df_norm, id = id_col_name,
                       samplenames1 = grp1_col_name,
                       samplenames2 = grp2_col_name,
                       test = "modt")
    df_peca$prot <- rownames(df_peca)
    # ups proteins
    df_peca$ups <- str_detect(df_peca$prot, "ups") * 1
    
    # truly de proteins
    df_peca$de <- df_peca$ups
    # ups proteins that are not DE
    for (i in 1:nrow(df_peca)){
        df_peca$de[i] <- ifelse(any(str_detect(rep(df_peca$prot[i], 8), ups_non_de)),
                                0, df_peca$ups[i])
    }

    df_peca_ratio <- df_peca %>%
        filter(ups == 1) %>%
        mutate(protid = str_replace(prot, "^([OPQ].*)ups\\|.*", "\\1")) %>%
        mutate(protid = str_split(protid, "-", simplify = TRUE)[, 1]) %>%
        select(-prot) %>%
        left_join(ups_true_df, by = "protid") %>%
        mutate(sr = 2^slr) # peca returns log2 fold change
    
    sqr_err <- (log10(df_peca_ratio$sr) - log10(df_peca_ratio$ratios))^2
    rmsle <- sqrt(mean(sqr_err, na.rm = TRUE))
    sd <- sd(sqr_err, na.rm = TRUE)
    df_roc <- pROC::roc(df_peca$de, df_peca$p)
    
    return(list("peca" = df_peca_ratio,
                "full_peca" = df_peca,
                "roc" = df_roc,
                "rmsle" = rmsle,
                "sd" = sd))
}
```
```{r peptides, warning=FALSE,message=FALSE}
norm_methods <- c("cyclicloess", "scale", "quantile", "vsn")
quant_methods <- c("moFF",  "moFF_no_MBR", "FlashLFQ",
                   "FlashLFQ_no_MBR", "MaxQuant", "MaxQuant_no_MBR")
quants <- list("moFF" = moff,  "moFF_no_MBR" = moff_no_mbr,
               "FlashLFQ" = flash, "FlashLFQ_no_MBR" = flash_no_mbr,
               "MaxQuant" = mq, "MaxQuant_no_MBR" = mq_no_mbr)
method_list <- expand.grid(norm_methods, quant_methods, stringsAsFactors = FALSE)
results <- vector(length = nrow(method_list), mode = "list")
# aucs <- rep(0, nrow(method_list))
rmses <- rep(0, nrow(method_list))
for (i in 1:nrow(method_list)){
  if (i != 14){
    df <- quants[[method_list$Var2[i]]]
    names_df <- names(df)
    ith_result <- peptides_normalize_and_test_de(df,
                                    int_col_vec = 3:10,
                                    id_col_name = 'prot',
                                    norm_method =  method_list$Var1[i],
                                    grp1_col_name = names_df[7:10],
                                    grp2_col_name = names_df[3:6])
    results[[i]] <- ith_result
    # aucs[i] <- ith_result$roc$auc
    rmses[i] <- ith_result$rmsle
  }
}

all_df <- cbind(method_list, rmsle = rmses)
```

#### Add Protein level
```{r proteins}
fc_accuracy <- rbind(all_df, mq_data$rmlse, mq_no_mbr_data$rmlse) %>%
    rename("Normalization" = Var1,
           "Tool" = Var2) 
write.table(fc_accuracy, file = "2019_results/fold_change_accuracy.tabular",
            quote = FALSE,
            row.names = FALSE,
            sep = '\t')
```

# Results


## RMSLE
Plot the results:

```{r plots, fig.width=14}
library(ggplot2)
ggplot(fc_accuracy) + 
    geom_bar(aes(x = Tool,
                 y = rmsle, fill = Normalization), position = "dodge",
             stat = "identity", color = "black") +
    theme_bw() +
    labs(x="Quantification", y="Root Mean Squared Error (Log10 scale)")
ggsave("UPS/mse.png")
```

## Table of TP, TN, FP, FN at 5% FDR 

```{r}
stat_df <- method_list %>%
    rename(Normalization = Var1,
           Tool = Var2)
nrows <- nrow(stat_df)
fdr_cut <- 0.05
tp <- fp <- tn <- fn <- nprot <- nprot_de <- rep(0, nrows)
for (i in 1:nrows){
    resloc <- results[[i]]$full_peca[results[[i]]$full_peca$n > 0, ]
    nprot[i] <- sum(resloc$n != 0)
    nprot_de[i] <- sum(resloc$n != 0 & resloc$de == 1)
    tp[i] <- sum(resloc$p.fdr <= fdr_cut & resloc$de == 1) # tp
    fp[i] <- sum(resloc$p.fdr <= fdr_cut & resloc$de == 0) # not de, declared de
    tn[i] <- sum(resloc$p.fdr > fdr_cut & resloc$de == 0)
    fn[i] <- sum(resloc$p.fdr > fdr_cut & resloc$de == 1)
}

# maxquant
mq_full_df <- mq_data$full_df
mq_nprot <- nrow(mq_full_df)
mq_de <- with(mq_full_df, sum(de == 1))
mq_tp <- with(mq_full_df, sum(p.fdr <= fdr_cut & de == 1)) 
mq_fp <- with(mq_full_df, sum(p.fdr <= fdr_cut & de == 0)) 
mq_tn <- with(mq_full_df, sum(p.fdr > fdr_cut & de == 0))
mq_fn <- with(mq_full_df, sum(p.fdr > fdr_cut &  de == 1))
mq_stat <- c("Normalization" = "MaxLFQ",
             "Tool" = "MaxQuant",
             nprot = mq_nprot,
             nprot_de = mq_de,
             tp = mq_tp,
             fn = mq_fn,
             fp = mq_fp,
             tn = mq_tn)

mq_no_mbr_full_df <- mq_no_mbr_data$full_df
mq_no_mbr_nprot <- nrow(mq_no_mbr_full_df)
mq_no_mbr_de <- with(mq_no_mbr_full_df, sum(de == 1))
mq_no_mbr_tp <- with(mq_no_mbr_full_df, sum(p.fdr <= fdr_cut & de == 1)) 
mq_no_mbr_fp <- with(mq_no_mbr_full_df, sum(p.fdr <= fdr_cut & de == 0)) 
mq_no_mbr_tn <- with(mq_no_mbr_full_df, sum(p.fdr > fdr_cut & de == 0))
mq_no_mbr_fn <- with(mq_no_mbr_full_df, sum(p.fdr > fdr_cut &  de == 1))
mq_no_mbr_stat <- c("Normalization" = "MaxLFQ",
                 "Tool" = "MaxQuant_no_Mbr",
              nprot = mq_no_mbr_nprot,
             nprot_de = mq_no_mbr_de,
             tp = mq_no_mbr_tp,
             fn = mq_no_mbr_fn,
             fp = mq_no_mbr_fp,
             tn = mq_no_mbr_tn)

stat_df$nprot <- nprot
stat_df$nprot_de <- nprot_de
stat_df$tp <- tp
stat_df$fn <- fn
stat_df$fp <- fp
stat_df$tn <- tn

stat_table <- rbind(stat_df, mq_stat, mq_no_mbr_stat) %>%
    mutate(TPR = as.numeric(tp)/40,
           FNR = as.numeric(fn)/40,
           tested = as.numeric(nprot_de)/40) %>%
    rename(TotalProtIDs = nprot,
           UpsDeProtDetected = nprot_de)
write.table(stat_table, file="2019_results/differential_expression_results.tab",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

```{r echo=FALSE,results='asis'}
kable(stat_table)
```

# High-Low Protein Abundance

```{r}
rmsles_hi <- rmsles_med <- rmsles_low <- n_low <- n_med <- n_hi <- rep(0, nrow(method_list))
rmsles_low <- rep(0, nrow(method_list))
for (i in 1:nrow(method_list)){
    peca_loc <- results[[i]]$peca
    hi <- peca_loc %>%
        filter(ratios == 10) 
    med <- peca_loc %>%
        filter(ratios == 0.1 | ratios == 0.01)
    low <- peca_loc %>%
        filter(ratios == 0.001 | ratios == 0.0001)
    n_hi[i] <- nrow(filter(hi, !is.na(sr)))
    rmsles_hi[i] <- sqrt(
        mean((log10(hi$ratios) - log10(hi$sr))^2, na.rm = TRUE)
     )
    n_med[i] <- nrow(filter(med, !is.na(sr)))
    rmsles_med[i] <- sqrt(
        mean((log10(med$ratios) - log10(med$sr))^2, na.rm = TRUE)
     )
    n_low[i] <- nrow(filter(low, !is.na(sr)))
    rmsles_low[i] <- sqrt(
        mean((log10(low$ratios) - log10(low$sr))^2, na.rm = TRUE)
    )
}

# maxquant, maxlfq, mbr
mq_hi <- filter(mq_data$joined_mq, ratios == 10)
mq_high_rmsle <- sqrt(mean((log10(mq_hi$ratios) - log10(mq_hi$sr))^2, na.rm = TRUE))
mq_n_high <- nrow(filter(mq_hi, !is.na(sr)))
mq_med <- filter(mq_data$joined_mq, ratios == 0.1 | ratios == 0.01)
mq_med_rmsle <- sqrt(mean((log10(mq_med$ratios) - log10(mq_med$sr))^2, na.rm = TRUE))
mq_n_med <- nrow(filter(mq_med, !is.na(sr)))
mq_low <- filter(mq_data$joined_mq, ratios == 0.001 | ratios == 0.0001)
mq_low_rmsle <- sqrt(mean((log10(mq_low$ratios) - log10(mq_low$sr))^2, na.rm = TRUE))
mq_n_low <- nrow(filter(mq_low, !is.na(sr)))

# maxquant, maxlfq, no mbr
# high
mq_no_mbr_hi <- filter(mq_no_mbr_data$joined_mq, ratios == 10)
mq_no_mbr_high_rmsle <- sqrt(
    mean((log10(mq_no_mbr_hi$ratios) - log10(mq_no_mbr_hi$sr))^2, na.rm = TRUE)
)
mq_no_mbr_n_high <- nrow(filter(mq_no_mbr_hi, !is.na(sr)))
# medium
mq_no_mbr_med <- filter(mq_no_mbr_data$joined_mq, ratios == 0.1 | ratios == 0.01)
mq_no_mbr_med_rmsle <- sqrt(
    mean((log10(mq_no_mbr_med$ratios) - log10(mq_no_mbr_med$sr))^2, na.rm = TRUE)
)
mq_no_mbr_n_med <- nrow(filter(mq_no_mbr_med, !is.na(sr)))
# low
mq_no_mbr_low <- filter(mq_no_mbr_data$joined_mq, ratios == 0.001 | ratios == 0.0001)
mq_no_mbr_low_rmsle <- sqrt(
    mean((log10(mq_no_mbr_low$ratios) - log10(mq_no_mbr_low$sr))^2, na.rm = TRUE)
)
mq_no_mbr_n_low <- nrow(filter(mq_no_mbr_low, !is.na(sr)))
himedlo <- cbind(method_list, "high" = rmsles_hi, "nhi" = n_hi,
              "med" = rmsles_med, "nmed" = n_med,
              "low" = rmsles_low, "nlow" = n_low)

mq_mbr <- c("Normalization" = "MaxLFQ",
             "Tool" = "MaxQuant",
             "high" = mq_high_rmsle,
            "nhi" = mq_n_high,
            "med" = mq_med_rmsle,
            "nmed" = mq_n_med,
            "low" = mq_low_rmsle,
            "nlow" = mq_n_low)

mq_no_mbr <- c("Normalization" = "MaxLFQ",
             "Tool" = "MaxQuant_no_MBR",
             "high" = mq_no_mbr_high_rmsle,
            "nhi" = mq_no_mbr_n_high,
            "med" = mq_med_rmsle,
            "nmed" = mq_no_mbr_n_med,
            "low" = mq_no_mbr_low_rmsle,
            "nlow" = mq_no_mbr_n_low)

all_himedlo <- rbind(himedlo, mq_mbr, mq_no_mbr) %>%
    rename("Normalization" = Var1, "Tool" = Var2)

write.table(all_himedlo, file="2019_results/high_low_fold_change_accuracy_new.tab",
            sep="\t", quote=FALSE, row.names=FALSE)
``` 

